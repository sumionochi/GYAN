<template>
  <div>
    <div v-if="isLoading" class="spinner-border" role="status">
      <span class="visually-hidden">Loading...</span>
    </div>
    <button
      v-else
      type="button"
      class="btn btn-sm btn-success rounded-pill px-3 py-2 fw-bold"
      @click="getPageContent"
    >
      Rewrite page content
    </button>
  </div>
</template>

<script setup lang="ts">
import { storeToRefs } from "pinia";
import { onMounted, ref } from "vue";
import { useUserStore } from "../stores/UserStore";
import {
  LengthOption,
  PreexistingKnowledge,
  RewriteCardData,
  WritingStyle,
} from "../types/types";

const isLoading = ref(false);
const userStore = useUserStore();
const userStoreRef = storeToRefs(userStore);

const apiKey = userStoreRef.userPrefs.value.password;

function replaceTextElements(
  apiKey: String,
  selectedWritingStyle: WritingStyle,
  selectedLengthOption: LengthOption,
  preexistingKnowledge: PreexistingKnowledge
) {
  // get all text elements (add or remove html tags as needed)
  const allParagraphs = document.querySelectorAll("p, figcaption, li");
  let paragraphText = "";

  // Test Console Logs
  paragraphText = "";
  allParagraphs.forEach((paragraph) => {
    const paragraphContent = paragraph?.textContent?.trim();
    if (paragraphContent) {
      paragraphText += paragraphContent + "\n";
    }
  });
  console.log(paragraphText);
  paragraphText = "";

  // filtering out unwanted text
  const paragraphs: Element[] = [];
  // remove all paragraphs that are in a header, footer, or nav element or parent class is navbox
  // Iterate over the selected elements and filter out unwanted ones
  allParagraphs.forEach((paragraph) => {
    const paragraphContent = paragraph?.textContent?.trim();

    // Check if the paragraph is within a <header>, <footer>, or <nav> element or has the class 'navbox'
    // can add more classes or tags to exclude here
    const isInHeaderFooterNavOrHasNavbox =
      paragraph.closest("header, footer, nav") ||
      paragraph.closest(
        ".navbox, .sidebar, .catlinks, .reflist, .mwe-math-element, .document-sidebar-rel-art"
      );

    // If the paragraph isn't any of the above, add it to the final paragraphs array
    if (paragraphContent && isInHeaderFooterNavOrHasNavbox) {
      // this is a text element we do not want
    } else if (paragraphContent) {
      paragraphText += paragraphContent + "\n";
      paragraphs.push(paragraph);
    }
  });

  // console.log(paragraphText);

  // just for printing / debug
  paragraphs.forEach((paragraph) => {
    const paragraphContent = paragraph?.textContent?.trim();
    if (paragraphContent) {
      // console.log(paragraphContent);
    }
  });

  // variable to store extracted paragraphs and their ids (ids are generated by us based on the order of the paragraphs)
  interface ExtractedParagraph {
    id: string;
    content: string;
  }
  interface ExtractedLinks {
    [key: string]: ExtractedLink;
  }
  interface ExtractedLink {
    link: string;
    paragraphId: Array<string | number>;
  }

  const extractedParagraphs: ExtractedParagraph[] = [];
  // variable to store extracted links and the paragraphs that use them
  const extractedLinks: ExtractedLinks = {};

  // max characters defines upper limit on each group (needed to stay under the openai token limit)
  const maxCharacters = 3000;
  let totalCharacters = 0;

  paragraphs.forEach((paragraph, index) => {
    const paragraphContent = paragraph?.textContent?.trim();
    const paragraphId = index + 1;
    if (paragraphContent) {
      extractedParagraphs.push({
        id: paragraphId.toString(),
        content: paragraphContent || "",
      });
    }

    // extract links from paragraph
    const links = paragraph.querySelectorAll("a");
    // find links within the paragraph and store their text and href in a dictionary that includes text, link, and paragraph ids
    links.forEach((link) => {
      const linkText = link?.textContent?.trim();
      const linkHref = link?.href;
      // if link already exists, add the paragraph id to the list of paragraphs that use it
      // otherwise, create a new entry in the dictionary
      if (linkText && linkHref) {
        if (extractedLinks[linkText]) {
          extractedLinks[linkText].paragraphId.push(paragraphId);
        } else {
          extractedLinks[linkText] = {
            link: linkHref,
            paragraphId: [paragraphId],
          };
        }
      }
    });
  });

  // at this point, we want to create groups of paragraphs to send to the LLM
  // we need to create groups to stay under the maximum token count
  // we also want to keep paragraphs together, so we can't split them up

  const groupedParagraphs = [];
  let currentGroup: ExtractedParagraph[] = [];
  extractedParagraphs.forEach((paragraph) => {
    const paragraphLength = paragraph.content.length;
    if (totalCharacters + paragraphLength > maxCharacters) {
      groupedParagraphs.push(currentGroup);
      currentGroup = [];
      totalCharacters = 0;
    }
    currentGroup.push(paragraph);
    totalCharacters += paragraphLength;
  });

  // push the last group since it didn't hit the token limit
  groupedParagraphs.push(currentGroup);

  // groupedParagraphs.forEach((group) => {
  //   console.log("Group")
  //   console.log(group);
  // });

  // cap groupedParagraphs at X groups (for testing, uncomment to do entire document)
  // groupedParagraphs.splice(4);

  // get page URL
  const url: string = window.location.href;
  // get page title
  const title: string = document.title;
  // get date
  const date: string = new Date().toLocaleDateString();
  const icon: string = "pencil";

  interface ApiResponse {
    id: string;
    response: string;
  }

  const apiResponses: ApiResponse[] = [];
  const totalGroups: number = groupedParagraphs.length;
  let currentGroupNumber: number = 0;

  // send groups to openai in a loop

  groupedParagraphs.forEach((group) => {
    // map elements to string to send to openai
    const extractedParagraphsString = group
      .map((paragraph) => {
        return `${paragraph.id}: ${paragraph.content}`;
      })
      .join("\n");

    console.log("Input:");
    console.log(extractedParagraphsString);

    // send to openai
    console.log("Sending group to OpenAI");
    const apiUrl = "https://api.openai.com/v1/chat/completions";

    let userPrompt =
      "You are a bot that rewrites content. You maintain the format, rewriting the content in place, aiming for a similar number of characters for each section. Maintain the same format as the input, with ids. Keep the same ids. If there is a blank, leave it there. Do NOT add headers, new lines, or anything else. Please rewrite this content to match a 1st grade reading level:\n1: Aerospace engineering is the primary field of engineering concerned with the development of aircraft and spacecraft.[3]  It has two major and overlapping branches: aeronautical engineering and astronautical engineering.  Avionics engineering is similar, but deals with the electronics side of aerospace engineering.\n4: Orville and Wilbur Wright flew the Wright Flyer in 1903 at Kitty Hawk, North Carolina.\n6: Early knowledge of aeronautical engineering was largely empirical, with some concepts and skills imported from other branches of engineering.[11] Some key elements, like fluid dynamics, were understood by 18th-century scientists.[12]\n7: In December 1903, the Wright Brothers performed the first sustained, controlled flight of a powered, heavier-than-air aircraft, lasting 12 seconds. The 1910s saw the development of aeronautical engineering through the design of World War I military aircraft.";

    let assistantResponse =
      "1: Aerospace engineering is about making planes and spaceships. There are two main parts: aeronautical engineering and astronautical engineering. Avionics engineering is similar, but it focuses on the electronics.\n4: The Wright brothers were the first to fly an airplane in 1903.\n6: Early knowledge of aeronautical engineering was based on observation and trial and error. Some key ideas, like how fluids move, were already understood by scientists in the 1700s.\n7: In 1903, the Wright brothers flew the first airplane that could stay in the air. During World War I, aeronautical engineering grew because of the need to design military planes.";

    let prompt =
      "Perfect formatting. As you know, you maintain the format, rewriting the content in place, aiming for a similar number of characters for each section. Maintain the same format as the input, with ids. Keep the same ids. If there is a blank, leave it there. Do NOT add headers, new lines, or anything else. For your next task, please rewrite this content at a ";
    prompt += selectedWritingStyle.text;
    prompt += " level, and make each section ";
    prompt += selectedLengthOption.text;
    prompt += " length";
    if (preexistingKnowledge.text) {
      prompt += ", I am skilled in: ";
      prompt += preexistingKnowledge.text;
      prompt +=
        ", so please use that knowledge to help rewrite this content, using metaphors that would help my understanding.";
      prompt += "\nContent";
    }
    prompt += ":\n";

    console.log(prompt);

    prompt += extractedParagraphsString;

    let messages = [
      {
        role: "user",
        content: userPrompt,
      },
      {
        role: "assistant",
        content: assistantResponse,
      },
      {
        role: "user",
        content: prompt,
      },
    ];

    fetch(apiUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: "Bearer " + apiKey,
      },
      body: JSON.stringify({
        model: "gpt-3.5-turbo",
        messages: messages,
        temperature: 0.9,
      }),
    })
      .then((response) => response.json())
      .then((responseData) => {
        //console.log(responseData);
        let response = responseData["choices"][0]["message"]["content"];
        console.log("OpenAI Response:");
        console.log(response);
        if (response) {
          // according to our format, there should never be more than one new line in a row, including whitespace
          // let's replace all instances of more than one newline with a single newline
          response = response.replace(/(\\n\s*){2,}/g, "\n");
          response = response.replace(/(\D{1,}: )/g, "");

          // get the paragraphs by splitting the response on newlines
          // TODO: This breaks if a page uses newlines within a single element
          // works fine for now though and it isn't too noticable so....
          const responseParagraphs: string[] = response.split("\n");
          // console.log(responseParagraphs);
          // ugh, sometimes OpenAI straight up ignores the formatting and just rewrites content

          // create dict of responseParagraph ids and text (parse the response)
          interface responseParagraphDict {
            [key: string]: string;
          }

          const responseParagraphsDict: responseParagraphDict = {};
          responseParagraphs.forEach((responseParagraph) => {
            // id is at beginning of each paragraph, in the form 1: or 2: etc.
            const id = responseParagraph.split(": ")[0];
            const splitText = responseParagraph.split(": ");
            // rejoin the rest of the paragraph since there may be more than one colon
            let replacementText = splitText.slice(1).join(": ");
            responseParagraphsDict[id] = replacementText;

            apiResponses.push({
              id: id,
              response: replacementText,
            });
          });

          currentGroupNumber++;
          if (currentGroupNumber >= totalGroups) {
            // parsed each response, so let's sort them and throw in the user store
            apiResponses.sort((a: any, b: any) => a.id - b.id);
            // console.log(apiResponses);

            // drop any responses that don't have an id or if it is empty
            apiResponses.filter(
              (response) => response.id != "" && response.response != "\n"
            );
            const groupedResponses: string = apiResponses
              .map((response) => response.id + ": " + response.response)
              .join("\n");
            // console.log(groupedResponses);

            const cardData: RewriteCardData = {
              dataType: "rewrite",
              title: title,
              url: url,
              icon: icon,
              dateAdded: date,
              text: groupedResponses,
              writingStyle: selectedWritingStyle,
              lengthOption: selectedLengthOption,
              preexistingKnowledge: preexistingKnowledge,
            };
            chrome.runtime.sendMessage({
              action: "storeRewriteData",
              content: cardData,
            });
          }

          // replace inner text of text nodes with the response text elements from OpenAI
          paragraphs.forEach((paragraph, index) => {
            // since paragraphs includes all paragraphs on the page, we need to check if the index is in the responseParagraphsDict for this specific openAI response
            if (responseParagraphsDict[index + 1]) {
              // console.log(
              //   "Original Paragraph " + index + ": " + paragraph.textContent
              // );
              // console.log(
              //   "Replacement Paragraph: " +
              //     (index + 1) +
              //     ", " +
              //     responseParagraphsDict[index + 1]
              // );

              let replacementText = responseParagraphsDict[index + 1];

              // go through, and wherever the link text is re-used, replace it with a link
              // TODO: this link replacement is case sensitive, may want to change that.
              for (const linkText in extractedLinks) {
                if (replacementText.includes(linkText)) {
                  // also check if it belongs to same paragraph
                  // TODO: may need to add additional styling depending on page
                  if (
                    extractedLinks[linkText].paragraphId.includes(index + 1)
                  ) {
                    replacementText = replacementText.replace(
                      linkText,
                      `<a href="${extractedLinks[linkText].link}">${linkText}</a>`
                    );
                  }
                }
              }

              // add the links that don't appear in the rewritten text below the paragraph
              const realLinks = Object.keys(extractedLinks).filter(
                (linkText) =>
                  extractedLinks[linkText].paragraphId.includes(index + 1) &&
                  !linkText.includes("[") &&
                  !linkText.includes("]") &&
                  !replacementText.includes(linkText)
              );

              if (realLinks.length > 0) {
                const linksHtmtl = realLinks
                  .map(
                    (linkText) =>
                      `<a href="${extractedLinks[linkText].link}">${linkText}</a>`
                  )
                  .join(", ");
                replacementText += "<br><br>Other Links: " + linksHtmtl;
              }

              // also add the references at the bottom
              const refLinks = Object.keys(extractedLinks).filter(
                (linkText) =>
                  extractedLinks[linkText].paragraphId.includes(index + 1) &&
                  linkText.includes("[") &&
                  linkText.includes("]")
              );
              if (refLinks.length > 0) {
                const refLinksHtml = refLinks
                  .map(
                    (linkText) =>
                      `<a href="${extractedLinks[linkText].link}">${linkText}</a>`
                  )
                  .join(", ");
                replacementText += `<br>References: ${refLinksHtml}`;
              }

              replacementText += "<br>";

              // replace the text! 🤓
              paragraph.innerHTML = replacementText;
            }
          });
        }
      })
      .catch((error) => {
        console.log(error);
      });
  });
}

const getPageContent = () => {
  isLoading.value = true;

  const selectedWritingStyle = userStoreRef.selectedWritingStyle.value;
  const selectedLengthOption = userStoreRef.selectedLengthOption.value;
  const preexistingKnowledge = userStoreRef.preexistingKnowledge.value;

  // get active tab and execute replaceTextElements on it
  chrome.tabs.query({ active: true, currentWindow: true }, function (tabs) {
    if (tabs && tabs.length > 0) {
      const activeTab = tabs[0];
      if (activeTab && activeTab.id) {
        console.log("Sending rewrite message to tab " + activeTab.id);
        console.log(activeTab);
        chrome.scripting.executeScript({
          target: { tabId: activeTab.id },
          func: replaceTextElements,
          args: [
            apiKey,
            selectedWritingStyle,
            selectedLengthOption,
            preexistingKnowledge,
          ],
        });
      } else {
        console.error("Error: Invalid tab object");
      }
    } else {
      console.error("Error: No active tabs found");
    }
  });
};

onMounted(() => {
  if (chrome.runtime && chrome.runtime.onMessage) {
    chrome.runtime.onMessage.addListener(function (request) {
      if (request.action === "storeRewriteData") {
        isLoading.value = false;
        console.log("Received storeRewrite message");
        console.log(request.content);
        const cardData: RewriteCardData = request.content;
        userStoreRef.rewriteCardData.value.push(cardData);
      } else {
        isLoading.value = false;
        console.log("Received unknown message");
        console.log(request);
      }
    });
  }
});
</script>

<style scoped></style>

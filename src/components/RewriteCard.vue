<template>
  <div
    @click="openRewrittenContent()"
    class="d-flex flex-wrap"
    style="cursor: pointer"
  >
    <div class="bg-light rounded-2 p-3 position-relative">
      <font-awesome-icon
        class="position-absolute rounded-pill bg-dark text-white p-2 card-icon"
        :icon="faPencilAlt"
      />
      <p class="fw-bold">{{ props.cardData.title }}</p>
      <p>{{ props.cardData.writingStyle.text }}</p>
      <p>{{ props.cardData.lengthOption.text }}</p>
      <p>{{ props.cardData.preexistingKnowledge?.text }}</p>
    </div>
  </div>
</template>

<script setup lang="ts">
import { faPencilAlt } from "@fortawesome/free-solid-svg-icons";
import { FontAwesomeIcon } from "@fortawesome/vue-fontawesome";
import { onMounted } from "vue";
import { RewriteCardData } from "../types/types.ts";

type PropTypes = {
  cardData: RewriteCardData;
};

const props = defineProps<PropTypes>();

function openRewrittenContent() {
  console.log("Opening rewritten content");
  const cardData = props.cardData;
  const url = cardData.url;
  chrome.tabs.create({ url: url, active: false }, (tab) => {
    console.log("Tab created: " + tab.id);

    if (cardData.text) {
      // Listen for tab update events
      chrome.tabs.onUpdated.addListener(function (tabId, changeInfo) {
        // Wait for the tab to complete loading
        if (tabId === tab.id && changeInfo.status === "complete") {
          // Execute your function after the tab has loaded
          chrome.scripting.executeScript({
            target: { tabId: tab.id },
            func: reinsertGeneratedText,
            args: [cardData.text],
          });
          // need to make tab active now, since we've had a chance to inject the script before the popup closes
          chrome.tabs.update(tab.id, { active: true });
        }
      });
    }
  });
}

function reinsertGeneratedText(text: string | undefined) {
  console.log("Reinserting generated text");
  // I'm sorry Patrick, this is gonna be MESSY
  // we will fix later after we win ðŸ™‚

  // get all text elements (add or remove html tags as needed)
  const allParagraphs = document.querySelectorAll("p, figcaption, li");
  let paragraphText = "";

  // Test Console Logs
  paragraphText = "";
  allParagraphs.forEach((paragraph) => {
    const paragraphContent = paragraph?.textContent?.trim();
    if (paragraphContent) {
      paragraphText += paragraphContent + "\n";
    }
  });
  console.log(paragraphText);
  paragraphText = "";

  // filtering out unwanted text
  const paragraphs: Element[] = [];
  // remove all paragraphs that are in a header, footer, or nav element or parent class is navbox
  // Iterate over the selected elements and filter out unwanted ones
  allParagraphs.forEach((paragraph) => {
    const paragraphContent = paragraph?.textContent?.trim();

    // Check if the paragraph is within a <header>, <footer>, or <nav> element or has the class 'navbox'
    // can add more classes or tags to exclude here
    const isInHeaderFooterNavOrHasNavbox =
      paragraph.closest("header, footer, nav") ||
      paragraph.closest(
        ".navbox, .sidebar, .catlinks, .reflist, .mwe-math-element, .document-sidebar-rel-art"
      );

    // If the paragraph isn't any of the above, add it to the final paragraphs array
    if (paragraphContent && isInHeaderFooterNavOrHasNavbox) {
      // this is a text element we do not want
    } else if (paragraphContent) {
      paragraphText += paragraphContent + "\n";
      paragraphs.push(paragraph);
    }
  });

  // console.log(paragraphText);

  // just for printing / debug
  paragraphs.forEach((paragraph) => {
    const paragraphContent = paragraph?.textContent?.trim();
    if (paragraphContent) {
      console.log(paragraphContent);
    }
  });

  // variable to store extracted paragraphs and their ids (ids are generated by us based on the order of the paragraphs)
  interface ExtractedParagraph {
    id: string;
    content: string;
  }
  interface ExtractedLinks {
    [key: string]: ExtractedLink;
  }
  interface ExtractedLink {
    link: string;
    paragraphId: Array<string | number>;
  }

  const extractedParagraphs: ExtractedParagraph[] = [];
  // variable to store extracted links and the paragraphs that use them
  const extractedLinks: ExtractedLinks = {};

  paragraphs.forEach((paragraph, index) => {
    const paragraphContent = paragraph?.textContent?.trim();
    const paragraphId = index + 1;
    if (paragraphContent) {
      extractedParagraphs.push({
        id: paragraphId.toString(),
        content: paragraphContent || "",
      });
    }

    // extract links from paragraph
    const links = paragraph.querySelectorAll("a");
    // find links within the paragraph and store their text and href in a dictionary that includes text, link, and paragraph ids
    links.forEach((link) => {
      const linkText = link?.textContent?.trim();
      const linkHref = link?.href;
      // if link already exists, add the paragraph id to the list of paragraphs that use it
      // otherwise, create a new entry in the dictionary
      if (linkText && linkHref) {
        if (extractedLinks[linkText]) {
          extractedLinks[linkText].paragraphId.push(paragraphId);
        } else {
          extractedLinks[linkText] = {
            link: linkHref,
            paragraphId: [paragraphId],
          };
        }
      }
    });
  });

  const response = text;

  if (response) {
    const responseParagraphs: string[] = response.split("\n");
    console.log(responseParagraphs);
    // ugh, sometimes OpenAI straight up ignores the formatting and just rewrites content

    // create dict of responseParagraph ids and text (parse the response)
    interface responseParagraphDict {
      [key: string]: string;
    }

    const responseParagraphsDict: responseParagraphDict = {};
    responseParagraphs.forEach((responseParagraph) => {
      // id is at beginning of each paragraph, in the form 1: or 2: etc.
      const id = responseParagraph.split(": ")[0];
      const splitText = responseParagraph.split(": ");
      // rejoin the rest of the paragraph since there may be more than one colon
      let replacementText = splitText.slice(1).join(": ");
      responseParagraphsDict[id] = replacementText;
    });

    paragraphs.forEach((paragraph, index) => {
      // since paragraphs includes all paragraphs on the page, we need to check if the index is in the responseParagraphsDict for this specific openAI response
      if (responseParagraphsDict[index + 1]) {
        console.log(
          "Original Paragraph " + index + ": " + paragraph.textContent
        );
        console.log(
          "Replacement Paragraph: " +
            (index + 1) +
            ", " +
            responseParagraphsDict[index + 1]
        );

        let replacementText = responseParagraphsDict[index + 1];

        // go through, and wherever the link text is re-used, replace it with a link
        for (const linkText in extractedLinks) {
          if (replacementText.includes(linkText)) {
            // also check if it belongs to same paragraph
            // TODO: may need to add additional styling depending on page
            if (extractedLinks[linkText].paragraphId.includes(index + 1)) {
              replacementText = replacementText.replace(
                linkText,
                `<a href="${extractedLinks[linkText].link}">${linkText}</a>`
              );
            }
          }
        }

        // add the links that don't appear in the rewritten text below the paragraph
        const realLinks = Object.keys(extractedLinks).filter(
          (linkText) =>
            extractedLinks[linkText].paragraphId.includes(index + 1) &&
            !linkText.includes("[") &&
            !linkText.includes("]") &&
            !replacementText.includes(linkText)
        );

        if (realLinks.length > 0) {
          const linksHtmtl = realLinks
            .map(
              (linkText) =>
                `<a href="${extractedLinks[linkText].link}">${linkText}</a>`
            )
            .join(", ");
          replacementText += "<br><br>Other Links: " + linksHtmtl;
        }

        // also add the references at the bottom
        const refLinks = Object.keys(extractedLinks).filter(
          (linkText) =>
            extractedLinks[linkText].paragraphId.includes(index + 1) &&
            linkText.includes("[") &&
            linkText.includes("]")
        );
        if (refLinks.length > 0) {
          const refLinksHtml = refLinks
            .map(
              (linkText) =>
                `<a href="${extractedLinks[linkText].link}">${linkText}</a>`
            )
            .join(", ");
          replacementText += `<br>References: ${refLinksHtml}`;
        }

        replacementText += "<br>";

        // replace the text! ðŸ¤“
        paragraph.innerHTML = replacementText;
      }
    });
  }
}

onMounted(() => {
  console.log(props.cardData);
});
</script>

<style scoped>
.card-icon {
  top: 0;
  right: 0;
  transform: translate(25%, -25%);
}
</style>
